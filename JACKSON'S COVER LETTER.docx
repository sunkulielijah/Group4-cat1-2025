# node.py - Run this in Terminals 2, 3, and 4 (with different node_id)
import socket
import json
import threading
import time
import sys
from datetime import datetime

class Account:
    def __init__(self, account_id, balance):
        self.id = account_id
        self.balance = balance
        self.lock = threading.Lock()
        self.transaction_log = []
    
    def __str__(self):
        return f"{self.id}: ${self.balance:.2f}"

class ParticipantNode:
    def __init__(self, node_id, host='localhost', port=6000):
        self.node_id = node_id
        self.host = host
        self.port = port + int(node_id[-1])  # Different port for each node
        self.accounts = {}
        self.transactions = {}
        self.active = True
        self.coordinator_host = 'localhost'
        self.coordinator_port = 5000
        
        # Initialize accounts for this node
        self._initialize_accounts()
        
        # Register with coordinator
        self.register_with_coordinator()
    
    def _initialize_accounts(self):
        """Initialize accounts based on node ID"""
        if self.node_id == "NODE-1":
            self.accounts = {
                "ACC001": Account("ACC001", 1000.0),
                "ACC002": Account("ACC002", 2000.0)
            }
        elif self.node_id == "NODE-2":
            self.accounts = {
                "ACC003": Account("ACC003", 1500.0),
                "ACC004": Account("ACC004", 3000.0)
            }
        elif self.node_id == "NODE-3":
            self.accounts = {
                "ACC005": Account("ACC005", 500.0),
                "ACC006": Account("ACC006", 1000.0)
            }
        
        print(f"üí∞ Node {self.node_id} initialized with accounts:")
        for acc in self.accounts.values():
            print(f"  {acc}")
    
    def register_with_coordinator(self):
        """Register this node with the coordinator"""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.connect((self.coordinator_host, self.coordinator_port))
                message = {
                    "type": "REGISTER",
                    "node_id": self.node_id,
                    "host": self.host,
                    "port": self.port
                }
                s.sendall(json.dumps(message).encode())
                response = json.loads(s.recv(4096).decode())
                
                if response.get("status") == "REGISTERED":
                    print(f"‚úÖ Successfully registered with coordinator as {self.node_id}")
                else:
                    print(f"‚ùå Failed to register: {response}")
        except Exception as e:
            print(f"‚ùå Cannot connect to coordinator: {e}")
            print("Make sure coordinator is running first!")
            sys.exit(1)
    
    def handle_prepare(self, transaction_id, accounts, from_account, to_account, amount):
        """Handle prepare phase of 2PC"""
        print(f"\nüìã [NODE {self.node_id}] PREPARE request for {transaction_id}")
        
        # Check if node is active
        if not self.active:
            return {"status": "ERROR", "message": "Node not active"}
        
        # Check which accounts are on this node
        local_accounts = []
        for acc_id in accounts:
            if acc_id in self.accounts:
                local_accounts.append(acc_id)
        
        if not local_accounts:
            # No relevant accounts on this node
            return {"status": "PREPARED", "message": "No relevant accounts"}
        
        # Try to acquire locks for concurrency control
        acquired_locks = []
        try:
            for acc_id in local_accounts:
                account = self.accounts[acc_id]
                if account.lock.acquire(blocking=False):
                    acquired_locks.append(acc_id)
                    print(f"  üîí Acquired lock for {acc_id}")
                else:
                    # Couldn't acquire lock - release any acquired locks
                    for locked_acc in acquired_locks:
                        self.accounts[locked_acc].lock.release()
                    return {
                        "status": "ABORT",
                        "message": f"Could not acquire lock for {acc_id}"
                    }
            
            # Check balances for debit accounts
            if from_account in local_accounts:
                if self.accounts[from_account].balance < amount:
                    # Release locks
                    for acc_id in local_accounts:
                        self.accounts[acc_id].lock.release()
                    return {
                        "status": "ABORT",
                        "message": f"Insufficient funds in {from_account}"
                    }
            
            # Store transaction state
            self.transactions[transaction_id] = {
                "status": "PREPARED",
                "from_account": from_account,
                "to_account": to_account,
                "amount": amount,
                "local_accounts": local_accounts,
                "timestamp": datetime.now().isoformat()
            }
            
            return {"status": "PREPARED", "message": "Ready to commit"}
        
        except Exception as e:
            # Release any acquired locks on error
            for acc_id in local_accounts:
                if acc_id in self.accounts:
                    self.accounts[acc_id].lock.release()
            return {"status": "ERROR", "message": str(e)}
    
    def handle_commit(self, transaction_id):
        """Handle commit phase of 2PC"""
        print(f"\nüíæ [NODE {self.node_id}] COMMIT request for {transaction_id}")
        
        if transaction_id not in self.transactions:
            return {"status": "ERROR", "message": "Transaction not found"}
        
        transaction = self.transactions[transaction_id]
        
        try:
            # Execute the transfer
            if transaction["from_account"] in self.accounts:
                self.accounts[transaction["from_account"]].balance -= transaction["amount"]
                self.accounts[transaction["from_account"]].transaction_log.append(
                    f"[{datetime.now()}] Debit ${transaction['amount']:.2f} (TXN:{transaction_id})"
                )
            
            if transaction["to_account"] in self.accounts:
                self.accounts[transaction["to_account"]].balance += transaction["amount"]
                self.accounts[transaction["to_account"]].transaction_log.append(
                    f"[{datetime.now()}] Credit ${transaction['amount']:.2f} (TXN:{transaction_id})"
                )
            
            # Release locks
            for acc_id in transaction["local_accounts"]:
                self.accounts[acc_id].lock.release()
                print(f"  üîì Released lock for {acc_id}")
            
            transaction["status"] = "COMMITTED"
            print(f"  ‚úÖ Transaction {transaction_id} committed successfully")
            
            return {"status": "COMMITTED", "message": "Transaction committed"}
        
        except Exception as e:
            return {"status": "ERROR", "message": str(e)}
    
    def handle_rollback(self, transaction_id):
        """Handle rollback request"""
        print(f"\n‚Ü©Ô∏è  [NODE {self.node_id}] ROLLBACK request for {transaction_id}")
        
        if transaction_id in self.transactions:
            transaction = self.transactions[transaction_id]
            
            # Release locks without making changes
            for acc_id in transaction.get("local_accounts", []):
                if acc_id in self.accounts:
                    self.accounts[acc_id].lock.release()
                    print(f"  üîì Released lock for {acc_id}")
            
            transaction["status"] = "ROLLED_BACK"
            return {"status": "ROLLED_BACK", "message": "Transaction rolled back"}
        
        return {"status": "ERROR", "message": "Transaction not found"}
    
    def simulate_crash(self):
        """Simulate node crash"""
        print(f"\nüî• [NODE {self.node_id}] SIMULATING CRASH!")
        self.active = False
        
        # Release all locks (simulating crash)
        for account in self.accounts.values():
            try:
                account.lock.release()
            except:
                pass
        
        return {"status": "CRASHED", "message": "Node has crashed"}
    
    def recover(self):
        """Recover from crash"""
        print(f"\n‚úÖ [NODE {self.node_id}] RECOVERING FROM CRASH")
        self.active = True
        
        # In a real system, we would replay transaction logs here
        # For this demo, we'll just clear any prepared transactions
        to_remove = []
        for txn_id, txn in self.transactions.items():
            if txn.get("status") == "PREPARED":
                to_remove.append(txn_id)
        
        for txn_id in to_remove:
            del self.transactions[txn_id]
        
        return {"status": "RECOVERED", "message": "Node recovered"}
    
    def handle_request(self, data):
        """Handle incoming request"""
        try:
            message = json.loads(data)
            msg_type = message.get("type")
            
            if msg_type == "PREPARE":
                return self.handle_prepare(
                    message["transaction_id"],
                    message.get("accounts", []),
                    message["from_account"],
                    message["to_account"],
                    message["amount"]
                )
            
            elif msg_type == "COMMIT":
                return self.handle_commit(message["transaction_id"])
            
            elif msg_type == "ROLLBACK":
                return self.handle_rollback(message["transaction_id"])
            
            elif msg_type == "CHECK_ACCOUNTS":
                accounts = message.get("accounts", [])
                node_accounts = []
                for acc_id in accounts:
                    if acc_id in self.accounts:
                        node_accounts.append(acc_id)
                return {"status": "OK", "accounts": node_accounts}
            
            elif msg_type == "STATUS":
                accounts_info = [
                    {"id": acc.id, "balance": acc.balance}
                    for acc in self.accounts.values()
                ]
                return {
                    "status": "OK",
                    "node_id": self.node_id,
                    "active": self.active,
                    "accounts": accounts_info,
                    "pending_transactions": len([t for t in self.transactions.values() 
                                               if t.get("status") == "PREPARED"])
                }
            
            elif msg_type == "CRASH":
                return self.simulate_crash()
            
            elif msg_type == "RECOVER":
                return self.recover()
            
            else:
                return {"status": "ERROR", "message": f"Unknown message type: {msg_type}"}
        
        except Exception as e:
            return {"status": "ERROR", "message": str(e)}
    
    def start(self):
        """Start node server"""
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind((self.host, self.port))
        server.listen(5)
        
        print(f"\nüñ•Ô∏è  Node {self.node_id} running on {self.host}:{self.port}")
        print("Waiting for coordinator requests...")
        print("Press Ctrl+C to exit")
        
        try:
            while True:
                client, address = server.accept()
                threading.Thread(target=self.handle_connection, args=(client, address)).start()
        except KeyboardInterrupt:
            print(f"\nShutting down Node {self.node_id}...")
        finally:
            server.close()
    
    def handle_connection(self, client, address):
        """Handle incoming connection"""
        try:
            data = client.recv(4096)
            if data:
                response = self.handle_request(data)
                client.sendall(json.dumps(response).encode())
        except Exception as e:
            print(f"Error handling connection: {e}")
        finally:
            client.close()

def node_cli(node):
    """Simple CLI for node control"""
    print("\nCommands (type in this terminal):")
    print("  crash    - Simulate node crash")
    print("  recover  - Recover node")
    print("  status   - Show node status")
    print("  quit     - Exit")
    
    while True:
        try:
            cmd = input(f"\nnode-{node.node_id}> ").strip().lower()
            
            if cmd == "crash":
                node.simulate_crash()
                print("Node crashed! Try a transaction from coordinator...")
            
            elif cmd == "recover":
                node.recover()
            
            elif cmd == "status":
                print(f"\nNode {node.node_id} Status:")
                print(f"  Active: {'‚úÖ' if node.active else '‚ùå'}")
                print(f"  Accounts:")
                for acc in node.accounts.values():
                    print(f"    {acc}")
                print(f"  Pending transactions: {len([t for t in node.transactions.values() if t.get('status') == 'PREPARED'])}")
            
            elif cmd == "quit":
                print("Shutting down node...")
                break
            
            else:
                print("Unknown command. Try: crash, recover, status, quit")
        
        except KeyboardInterrupt:
            print("\nShutting down...")
            break
        except Exception as e:
            print(f"Error: {e}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Distributed Transaction Node')
    parser.add_argument('node_id', help='Node ID (e.g., NODE-1, NODE-2, NODE-3)')
    parser.add_argument('--host', default='localhost', help='Host address')
    parser.add_argument('--port', type=int, default=6000, help='Base port number')
    
    args = parser.parse_args()
    
    print("="*60)
    print(f"üñ•Ô∏è  STARTING NODE {args.node_id}")
    print("="*60)
    
    node = ParticipantNode(args.node_id, args.host, args.port)
    
    # Start node server in background thread
    server_thread = threading.Thread(target=node.start, daemon=True)
    server_thread.start()
    
    # Give server time to start
    time.sleep(1)
    
    # Start CLI
    node_cli(node)